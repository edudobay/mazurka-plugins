//
// Programmer:    Craig Stuart Sapp <craig@ccrma.stanford.edu>
// Creation Date: Fri Jun 16 23:19:44 PDT 2006
// Last Modified: Sat Jun 17 03:52:36 PDT 2006
// Last Modified: Sun May  6 01:48:58 PDT 2007 (upgraded to vamp 1.0)
// Filename:      ...plugin/MazurkaWindower/MazurkaWindower.h
// Syntax:        ANSI99 C++ 
//
// Description:   Interface for windowing audio signals.
//

#include "MazurkaWindower.h"
#include <math.h>


//////////////////////////////
//
// MazurkaWindower::MazurkaWindower -- constructor
//

MazurkaWindower::MazurkaWindower(void) {
   dataSize = 0;
   data     = NULL;
   dataType = "Unknown";
}


MazurkaWindower::MazurkaWindower(int size) {
   dataSize = 0;
   data = NULL;
   dataType = "Unknown";
   initialize(size);
}


MazurkaWindower::MazurkaWindower(int size, std::string type) {
   dataSize = 0;
   data = NULL;
   dataType = type;
   initialize(size);
   makeWindow(dataType, data, dataSize);
}



//////////////////////////////
//
// MazurkaWindower::~MazurkaWindower -- deconstructor
//

MazurkaWindower::~MazurkaWindower() {
   deinitialize();
}



//////////////////////////////
//
// MazurkaWindower::getWindowSum -- returns the sum of all
//    pieces of the window (the area of the window).
//

double MazurkaWindower::getWindowSum(void) {
   int size = dataSize;
   double sum = 0.0;
   for (int i=0; i<size; i++) {
      sum += data[i];
   }

   return sum; 
}


//////////////////////////////
//
// MazurkaWindower::getSize --
//

int MazurkaWindower::getSize(void) {
   return dataSize;
}



//////////////////////////////
//
// MazurkaWindower::setSize --
//

void MazurkaWindower::setSize(int size) {
   if (size != dataSize) {
      initialize(size);
      if (dataSize > 0) {
         makeWindow(dataType, data, dataSize);
      }
   }
}



//////////////////////////////
//
// MazurkaWindower::getWindowType -- return the type of window
//   which is present in the window array.
//

std::string MazurkaWindower::getWindowType(void) {
   return dataType;
}



//////////////////////////////
//
// MazurkaWindower::operator[] --
//

double& MazurkaWindower::operator[](int index) {
   static double dummy = 0.0;
   if (index < 0 && index >= dataSize) {
      return dummy;
   } else {
      return data[index];
   }
}



//////////////////////////////
//
// MazurkaWindower::operator= --
//

MazurkaWindower& MazurkaWindower::operator=(MazurkaWindower& aWindow) {
   if (&aWindow == this) {
      return *this;
   }

   deinitialize();
   initialize(aWindow.dataSize);
   for (int i=0; i<aWindow.dataSize; i++) {
      data[i] = aWindow.data[i];
   }
   dataType = aWindow.dataType;

   return *this;
}



//////////////////////////////
//
// MazurkaWindower::windowNonCausal --
//

void MazurkaWindower::windowNonCausal(MazurkaTransformer& transformer, 
      const float* buffer, int size) {

   int transformsize = transformer.getSize();
   int bottomhalf    = int(size / 2.0 + 0.6);
   int tophalf       = size - bottomhalf;
   int i;

   for (i=0; i<bottomhalf; i++) {
      transformer[i] = buffer[tophalf + i] * data[tophalf + i];
   }
      
   for (i=0; i<tophalf; i++) {
      transformer[transformsize - tophalf + i] = buffer[i] * data[i];
   }
}


/////////////////////////////////////////////////////////////////////////
//
// window creation functions
//

//////////////////////////////
//
// MazurkaWindower::getWindowList -- return a list of the known
//    windows which the object can create.
//

int MazurkaWindower::getWindowList(std::vector<std::string>& windows) {
   windows.clear();

   windows.push_back("Rectangular");
   windows.push_back("Hann");
   windows.push_back("Blackman");
   windows.push_back("BlackmanHarris4_92");
   windows.push_back("Triangular");

   return windows.size();
}


//////////////////////////////
//
// MazurkaWindower::getEnumeratedWindow -- return the value
//    of the enumerated window which is found in the list
//    generated by the above function: getWindowList.
//    Return "Unknown" if the index value is out of range.
//

std::string MazurkaWindower::getEnumeratedWindow(int enumeration) {
   if (enumeration < 0) {
      return "Unknown";
   }
   
   std::vector<std::string> windowlist;
   getWindowList(windowlist);
   
   if (enumeration >= (int)windowlist.size()) {
      return "Unknown";
   } else {
      return windowlist[enumeration];
   }
}



//////////////////////////////
//
// MazurkaWindower::makeWindow -- Make a window with a known name.
//     If no data array and size is given, use the current values
//     already setup the object.
//


int MazurkaWindower::makeWindow(std::string type) {
   if (dataSize > 0) {
      return makeWindow(type, data, dataSize);
   } else {
      return 0;
   }
}


int MazurkaWindower::makeWindow(int windowEnum) {
   std::string type = getEnumeratedWindow(windowEnum);
   if (dataSize > 0) {
      return makeWindow(type, data, dataSize);
   } else {
      return 0;
   }
}


int MazurkaWindower::makeWindow(std::string type, int size) {
   initialize(size);
   if (dataSize > 0) {
      return makeWindow(type, data, dataSize);
   } else {
      return 0;
   }
}


int MazurkaWindower::makeWindow(int windowEnum, int size) {
   std::string type = getEnumeratedWindow(windowEnum);
   initialize(size);
   if (dataSize > 0) {
      return makeWindow(type, data, dataSize);
   } else {
      return 0;
   }
}


int MazurkaWindower::makeWindow(std::string type, double* data, int size) {
   if (type == "Rectangular" || type == "Square") {
      makeSquareWindow(data, size);
      dataType = "Rectangular";
      return 1;
   } else if (type == "Hann" || type == "Hanning") {
      makeHannWindow(data, size);
      dataType = "Hann";
      return 1;
   } else if (type == "Blackman") {
      makeBlackmanWindow(data, size);
      dataType = "Blackman";
      return 1;
   } else if (type == "BlackmanHarris4_92") {
      makeBlackmanHarris4_92Window(data, size);
      dataType = "BlackmanHarris4_92";
      return 1;
   } else if (type == "Triangular" || type == "Fejer" || type == "Bartlett") {
      makeTriangularWindow(data, size);
      dataType = "Triangular";
      return 1;
   } else {
      dataType = "Unknown";
      return 0;
   }
}


//////////////////////////////////////////////////////////////////////////
//
// static window creation functions
//


//////////////////////////////
//
// MazurkaWindower::makeRectangularWindow --  Make a square window.
//

void MazurkaWindower::makeRectangularWindow(double* data, int size) {
   for (int i=0; i<size; i++) {
      data[i] = 1.0;
   }
}


void MazurkaWindower::makeSquareWindow(double* data, int size) {
   makeRectangularWindow(data, size);
}



//////////////////////////////
//
// MazurkaWindower::makeHannWindow -- Make a raised cosine window.
//

void MazurkaWindower::makeHannWindow(double* data, int size) {
   for (int i=0; i<size; i++) {
      data[i] = 0.5 - 0.5 * cos(2.0 * M_PI * i/size);
   }
}


void MazurkaWindower::makeHanningWindow(double* data, int size) {
   makeHannWindow(data, size);
}


//////////////////////////////
//
// MazurkaWindower::makeBlackmanWindow -- Default parameters are for
//     the classic 3-term Blackman Window.
//
//     Default Values: p1 = 7938/18608 : 0.426590713671539
//                     p2 = 9240/18608 : 0.496560619088564
//                     p3 = 1430/18608 : 0.076848667239896
//                     p4 = 0
//

void MazurkaWindower::makeBlackmanWindow(double* data, int size, 
      double p1, double p2, double p3, double p4) {
   for (int i=0; i<size; i++) {
      data[i] =   p1 - p2 * cos(2.0 * M_PI * i/size) 
                     + p3 * cos(4.0 * M_PI * i/size)
                     - p4 * cos(6.0 * M_PI * i/size);
   }
}



//////////////////////////////
//
// MazurkaWindower::makeBlackmanHarris4_92Window -- 4-term Blackman
//    window with a roll-off of -92 dB.
//

void MazurkaWindower::makeBlackmanHarris4_92Window(double* data, int size) {
   makeBlackmanWindow(data, size, 0.35875, 0.48829, 0.14128, 0.01168);
}


//////////////////////////////
//
// MazurkaWindower::makeTriangularWindow -- make a triangular window
//

void MazurkaWindower::makeTriangularWindow(double* data, int size) {
   double factor = (size - 1.0) / 2.0;
   for (int i=0; i<size; i++) {
      data[i] = (factor - fabs(i-factor))/factor;
   }
}

//
// People keep re-discovering simple geometric shapes:
//

void MazurkaWindower::makeBartlettWindow(double* data, int size) {
   makeTriangularWindow(data, size);
}


void MazurkaWindower::makeFejerWindow(double* data, int size) {
   makeTriangularWindow(data, size);
}



/////////////////////////////////////////////////////////////////////////
//
// protected functions
//


//////////////////////////////
//
// MazurkaWindower::initialize --
//

void MazurkaWindower::initialize(int size) {
   if (dataSize == size) {
      return;
   }

   deinitialize();

   if (size <= 0) {
      return;
   }

   data = new double[size];
   dataSize = size;
}



//////////////////////////////
//
// MazurkaWindower::deinitialize --
//

void MazurkaWindower::deinitialize(void) {
   delete [] data;
   dataSize = 0;
}




